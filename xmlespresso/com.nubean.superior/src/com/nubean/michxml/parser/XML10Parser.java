/* Generated By:JavaCC: Do not edit this line. XML10Parser.java */
/*
The MIT License (MIT)

Copyright (c) 2015 NuBean LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

package com.nubean.michxml.parser;

import com.nubean.michxml.XMLDocument;
import com.nubean.michxml.XMLNode;
import com.nubean.michbase.DefaultErrorHandler;
import com.nubean.michxml.elem.*;

import org.xml.sax.SAXParseException;

import java.util.*;

public class XML10Parser implements XML10ParserConstants {
        private XMLDocument doc;
        private Stack<Integer> sindex = new Stack<Integer>();
        private DefaultErrorHandler errorHandler;
        private ParseException lastException;
        private TokenMgrError tokenError;

        public void setErrorHandler(DefaultErrorHandler errorHandler) {
                this.errorHandler = errorHandler;
        }
        private XMLNode getNextXMLNode(XMLNode parent) {
            int cindex = sindex.pop().intValue();
            sindex.push(new Integer(cindex+1));
                return (parent != null ? parent.child(cindex) : null);
        }



        private void recoverFromError(ParseException e) {
         lastException = e;
         try {
                if(errorHandler != null) {

                        SAXParseException spe = null;
                                if(e.currentToken.next != null) {
                                        spe = new SAXParseException(e.getMessage(), null, null,
                                                e.currentToken.next.beginLine, e.currentToken.next.beginColumn);
                                } else {
                                        spe = new SAXParseException(e.getMessage(), null, null,
                                                e.currentToken.beginLine, e.currentToken.beginColumn);
                                }
                        errorHandler.error(spe);

        }

          } catch(Exception sae) {

      }

     }

     private void recoverFromError(TokenMgrError e) {
      tokenError = e;
          try {
                if(errorHandler != null) {
                        SAXParseException spe =
                         new SAXParseException(e.getMessage(), null, null,0,0);
                errorHandler.error(spe);
        }
          } catch(Exception sae) {

      }
     }

    public ParseException getParseException() {
        return lastException;
    }

    public TokenMgrError getTokenMgrError() {
        return tokenError;
    }

    private void switchTo(int state) {
        token_source.SwitchTo(state);
        if(token.next != null) {
                if(token.next.image != null)
                        jj_input_stream.backup(token.next.image.length());
                token.next = null;
        }
    }
    public void setTabSize(int size) {
     jj_input_stream.setTabSize(size);
    }

  final public Token KeyWords() throws ParseException {
  Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANY:
      tok = jj_consume_token(ANY);
      break;
    case RMD_ALL:
      tok = jj_consume_token(RMD_ALL);
      break;
    case RMD:
      tok = jj_consume_token(RMD);
      break;
    case RMD_NONE:
      tok = jj_consume_token(RMD_NONE);
      break;
    case EMPTY:
      tok = jj_consume_token(EMPTY);
      break;
    case VERSION:
      tok = jj_consume_token(VERSION);
      break;
    case RMD_INTERNAL:
      tok = jj_consume_token(RMD_INTERNAL);
      break;
    case ID:
      tok = jj_consume_token(ID);
      break;
    case IDREF:
      tok = jj_consume_token(IDREF);
      break;
    case IDREFS:
      tok = jj_consume_token(IDREFS);
      break;
    case ENTITY:
      tok = jj_consume_token(ENTITY);
      break;
    case ENTITIES:
      tok = jj_consume_token(ENTITIES);
      break;
    case NMTOKEN:
      tok = jj_consume_token(NMTOKEN);
      break;
    case NMTOKENS:
      tok = jj_consume_token(NMTOKENS);
      break;
    case NOTATION:
      tok = jj_consume_token(NOTATION);
      break;
    case CDATA:
      tok = jj_consume_token(CDATA);
      break;
    case NDATA:
      tok = jj_consume_token(NDATA);
      break;
    case IGNORE:
      tok = jj_consume_token(IGNORE);
      break;
    case INCLUDE:
      tok = jj_consume_token(INCLUDE);
      break;
    case PUBLIC:
      tok = jj_consume_token(PUBLIC);
      break;
    case SYSTEM:
      tok = jj_consume_token(SYSTEM);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return tok;}
    throw new Error("Missing return statement in function");
  }

  final public void doctypedecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(96);
                xmlNode = getNextXMLNode(xmlNode);

                XMLDocTypeElement dte = new XMLDocTypeElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLAbstractElement e = new XMLLabelElement(dte, dte.getEndOffset(), "<!DOCTYPE");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    if (jj_2_1(2)) {
      S(xmlNode, dte);
      ExternalID(xmlNode, dte);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DSO:
      jj_consume_token(DSO);
                e = new XMLLabelElement(dte, dte.getEndOffset(), "[");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
      intSubset(xmlNode, dte);
      jj_consume_token(DSC);
                e = new XMLLabelElement(dte, dte.getEndOffset(), "]");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, dte);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void Enumeration(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(97);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "(");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    label_1:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      jj_consume_token(98);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "|");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Name:
        t = jj_consume_token(Name);
        break;
      case VERSION:
      case ANY:
      case RMD:
      case RMD_NONE:
      case RMD_ALL:
      case RMD_INTERNAL:
      case EMPTY:
      case ID:
      case IDREF:
      case IDREFS:
      case ENTITY:
      case ENTITIES:
      case NMTOKEN:
      case NMTOKENS:
      case NOTATION:
      case CDATA:
      case NDATA:
      case IGNORE:
      case INCLUDE:
      case PUBLIC:
      case SYSTEM:
        t = KeyWords();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(99);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void elementdecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(100);
                ElementDeclElement dte = new ElementDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLLabelElement e = new XMLLabelElement(dte, dte.getEndOffset(), "<!ELEMENT");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    contentspec(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void AttlistDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(101);
                AttlistDeclElement dte = new AttlistDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLLabelElement e = new XMLLabelElement(dte, dte.getEndOffset(), "<!ATTLIST");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    label_2:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_2;
      }
      AttDef(xmlNode, dte);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void NotationDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(102);
                NotationDeclElement dte = new NotationDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLLabelElement e = new XMLLabelElement(dte, dte.getEndOffset(),"<!NOTATION");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    if (jj_2_4(2147483647)) {
      ExternalID(xmlNode, dte);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        PublicID(xmlNode, dte);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void AttDef(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    S(xmlNode, parent);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    S(xmlNode, parent);
    AttType(xmlNode, parent);
    S(xmlNode, parent);
    DefaultDecl(xmlNode, parent);
  }

  final public void DefaultDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
String value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUIRED:
      t = jj_consume_token(REQUIRED);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case IMPLIED:
      t = jj_consume_token(IMPLIED);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case FIXED:
    case DQuotedDO:
    case DQuotedSO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIXED:
        t = jj_consume_token(FIXED);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        S(xmlNode, parent);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      value = AttrValue();
                e = new XMLLabelElement(parent, parent.getEndOffset(), value);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AttType(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      t = jj_consume_token(CDATA);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case ID:
      t = jj_consume_token(ID);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case IDREF:
      t = jj_consume_token(IDREF);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case IDREFS:
      t = jj_consume_token(IDREFS);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case ENTITY:
      t = jj_consume_token(ENTITY);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case ENTITIES:
      t = jj_consume_token(ENTITIES);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case NMTOKEN:
      t = jj_consume_token(NMTOKEN);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case NMTOKENS:
      t = jj_consume_token(NMTOKENS);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case NOTATION:
    case 97:
      EnumeratedType(xmlNode, parent);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EnumeratedType(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTATION:
      NotationType(xmlNode, parent);
      break;
    case 97:
      Enumeration(xmlNode, parent);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NotationType(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    t = jj_consume_token(NOTATION);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    S(xmlNode, parent);
    jj_consume_token(97);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "(");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    label_3:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      jj_consume_token(98);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "|");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Name:
        t = jj_consume_token(Name);
        break;
      case VERSION:
      case ANY:
      case RMD:
      case RMD_NONE:
      case RMD_ALL:
      case RMD_INTERNAL:
      case EMPTY:
      case ID:
      case IDREF:
      case IDREFS:
      case ENTITY:
      case ENTITIES:
      case NMTOKEN:
      case NMTOKENS:
      case NOTATION:
      case CDATA:
      case NDATA:
      case IGNORE:
      case INCLUDE:
      case PUBLIC:
      case SYSTEM:
        t = KeyWords();
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(99);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void intSubset(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PISTART:
      case Space:
      case Perc:
      case Comment:
      case 100:
      case 101:
      case 102:
      case 103:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PISTART:
      case Comment:
      case 100:
      case 101:
      case 102:
      case 103:
        markupdecl(xmlNode, parent);
        break;
      case Space:
      case Perc:
        DeclSep(xmlNode, parent);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void DeclSep(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Perc:
      PEReference(xmlNode, parent);
      break;
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void markupdecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 100:
      elementdecl(xmlNode, parent);
      break;
    case 101:
      AttlistDecl(xmlNode, parent);
      break;
    case 103:
      EntityDecl(xmlNode, parent);
      break;
    case 102:
      NotationDecl(xmlNode, parent);
      break;
    case PISTART:
      PI(xmlNode, parent);
      break;
    case Comment:
      Comment(xmlNode, parent);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EntityDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    if (jj_2_6(3)) {
      GEDecl(xmlNode, parent);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 103:
        PEDecl(xmlNode, parent);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void GEDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(103);
                EntityDeclElement dte = new EntityDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLLabelElement e = new XMLLabelElement(dte, dte.getEndOffset(),"<!ENTITY");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    EntityDef(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void PEDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(103);
                EntityDeclElement dte = new EntityDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{dte};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLLabelElement e = new XMLLabelElement(dte, dte.getEndOffset(),"<!ENTITY");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    jj_consume_token(Perc);
    S(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(dte, dte.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
    S(xmlNode, dte);
    PEDef(xmlNode, dte);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, dte);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    jj_consume_token(TAGEND);
                e = new XMLLabelElement(dte, dte.getEndOffset(), ">");
                elems = new XMLAbstractElement[]{e};
                dte.replace(dte.getElementCount(), 0, elems);
  }

  final public void EntityDef(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DQuotedDO:
    case DQuotedSO:
      EntityValue(xmlNode, parent);
      break;
    case PUBLIC:
    case SYSTEM:
      ExternalID(xmlNode, parent);
      if (jj_2_7(2)) {
        NDataDecl(xmlNode, parent);
      } else {
        ;
      }
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EntityValue(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DQuotedDO:
      jj_consume_token(DQuotedDO);
          switchTo(EntityValueSectD);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "\u005c"");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VERSION:
        case ANY:
        case RMD:
        case RMD_NONE:
        case RMD_ALL:
        case RMD_INTERNAL:
        case EMPTY:
        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
        case NOTATION:
        case CDATA:
        case NDATA:
        case IGNORE:
        case INCLUDE:
        case PUBLIC:
        case SYSTEM:
        case Name:
        case Perc:
        case Amp:
        case ChRefHex:
        case ChRefDec:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VERSION:
        case ANY:
        case RMD:
        case RMD_NONE:
        case RMD_ALL:
        case RMD_INTERNAL:
        case EMPTY:
        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
        case NOTATION:
        case CDATA:
        case NDATA:
        case IGNORE:
        case INCLUDE:
        case PUBLIC:
        case SYSTEM:
        case Name:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Name:
            t = jj_consume_token(Name);
            break;
          case VERSION:
          case ANY:
          case RMD:
          case RMD_NONE:
          case RMD_ALL:
          case RMD_INTERNAL:
          case EMPTY:
          case ID:
          case IDREF:
          case IDREFS:
          case ENTITY:
          case ENTITIES:
          case NMTOKEN:
          case NMTOKENS:
          case NOTATION:
          case CDATA:
          case NDATA:
          case IGNORE:
          case INCLUDE:
          case PUBLIC:
          case SYSTEM:
            t = KeyWords();
            break;
          default:
            jj_la1[40] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
          break;
        case Perc:
          PEReference(xmlNode, parent);
                                           switchTo(EntityValueSectD);
          break;
        case Amp:
        case ChRefHex:
        case ChRefDec:
          Reference(xmlNode, parent);
                                        switchTo(EntityValueSectD);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(DQuotedDC);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "\u005c"");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case DQuotedSO:
      jj_consume_token(DQuotedSO);
    switchTo(EntityValueSectS);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "'");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VERSION:
        case ANY:
        case RMD:
        case RMD_NONE:
        case RMD_ALL:
        case RMD_INTERNAL:
        case EMPTY:
        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
        case NOTATION:
        case CDATA:
        case NDATA:
        case IGNORE:
        case INCLUDE:
        case PUBLIC:
        case SYSTEM:
        case Name:
        case Perc:
        case Amp:
        case ChRefHex:
        case ChRefDec:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VERSION:
        case ANY:
        case RMD:
        case RMD_NONE:
        case RMD_ALL:
        case RMD_INTERNAL:
        case EMPTY:
        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
        case NOTATION:
        case CDATA:
        case NDATA:
        case IGNORE:
        case INCLUDE:
        case PUBLIC:
        case SYSTEM:
        case Name:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Name:
            t = jj_consume_token(Name);
            break;
          case VERSION:
          case ANY:
          case RMD:
          case RMD_NONE:
          case RMD_ALL:
          case RMD_INTERNAL:
          case EMPTY:
          case ID:
          case IDREF:
          case IDREFS:
          case ENTITY:
          case ENTITIES:
          case NMTOKEN:
          case NMTOKENS:
          case NOTATION:
          case CDATA:
          case NDATA:
          case IGNORE:
          case INCLUDE:
          case PUBLIC:
          case SYSTEM:
            t = KeyWords();
            break;
          default:
            jj_la1[43] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
          break;
        case Perc:
          PEReference(xmlNode, parent);
                                           switchTo(EntityValueSectS);
          break;
        case Amp:
        case ChRefHex:
        case ChRefDec:
          Reference(xmlNode, parent);
                                        switchTo(EntityValueSectS);
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(DQuotedSC);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "'");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PEDef(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DQuotedDO:
    case DQuotedSO:
      EntityValue(xmlNode, parent);
      break;
    case PUBLIC:
    case SYSTEM:
      ExternalID(xmlNode, parent);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NDataDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    S(xmlNode, parent);
    t = jj_consume_token(NDATA);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    S(xmlNode, parent);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void PEReference(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
StringBuffer sb = new StringBuffer();
Token t;
    jj_consume_token(Perc);
             sb.append("%");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                   sb.append(t.image);
    jj_consume_token(SemiColon);
                       sb.append(";");
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), sb.toString());
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void contentspec(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EMPTY:
      t = jj_consume_token(EMPTY);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case ANY:
      t = jj_consume_token(ANY);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    default:
      jj_la1[49] = jj_gen;
      if (jj_2_8(3)) {
        Mixed(xmlNode, parent);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 97:
          children(xmlNode, parent);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void choice(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    jj_consume_token(97);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "(");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    cp(xmlNode, parent);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      jj_consume_token(98);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "|");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      cp(xmlNode, parent);
      if (jj_2_9(2)) {
        ;
      } else {
        break label_7;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    jj_consume_token(99);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void seq(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    jj_consume_token(97);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "(");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    cp(xmlNode, parent);
    label_8:
    while (true) {
      if (jj_2_10(2)) {
        ;
      } else {
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(104);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ",");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      cp(xmlNode, parent);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    jj_consume_token(99);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void cp(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
    case Name:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Name:
        t = jj_consume_token(Name);
        break;
      case VERSION:
      case ANY:
      case RMD:
      case RMD_NONE:
      case RMD_ALL:
      case RMD_INTERNAL:
      case EMPTY:
      case ID:
      case IDREF:
      case IDREFS:
      case ENTITY:
      case ENTITIES:
      case NMTOKEN:
      case NMTOKENS:
      case NOTATION:
      case CDATA:
      case NDATA:
      case IGNORE:
      case INCLUDE:
      case PUBLIC:
      case SYSTEM:
        t = KeyWords();
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    default:
      jj_la1[60] = jj_gen;
      if (jj_2_11(2147483647)) {
        choice(xmlNode, parent);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 97:
          seq(xmlNode, parent);
          break;
        default:
          jj_la1[61] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 105:
    case 106:
    case 107:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 105:
        jj_consume_token(105);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "?");
                 XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      case 106:
        jj_consume_token(106);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "*");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      case 107:
        jj_consume_token(107);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "+");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
  }

  final public void children(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    if (jj_2_12(2147483647)) {
      choice(xmlNode, parent);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 97:
        seq(xmlNode, parent);
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 105:
    case 106:
    case 107:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 105:
        jj_consume_token(105);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "?");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      case 106:
        jj_consume_token(106);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "*");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      case 107:
        jj_consume_token(107);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "+");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
  }

  final public void Mixed(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(97);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), "(");
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    t = jj_consume_token(PC);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    if (jj_2_14(2)) {
      label_9:
      while (true) {
        if (jj_2_13(2)) {
          ;
        } else {
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Space:
          S(xmlNode, parent);
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        jj_consume_token(98);
                e = new XMLLabelElement(parent, parent.getEndOffset(), "|");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Space:
          S(xmlNode, parent);
          break;
        default:
          jj_la1[69] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Name:
          t = jj_consume_token(Name);
          break;
        case VERSION:
        case ANY:
        case RMD:
        case RMD_NONE:
        case RMD_ALL:
        case RMD_INTERNAL:
        case EMPTY:
        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
        case NOTATION:
        case CDATA:
        case NDATA:
        case IGNORE:
        case INCLUDE:
        case PUBLIC:
        case SYSTEM:
          t = KeyWords();
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
        S(xmlNode, parent);
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
      jj_consume_token(99);
      jj_consume_token(106);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")*");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Space:
      case 99:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Space:
          S(xmlNode, parent);
          break;
        default:
          jj_la1[72] = jj_gen;
          ;
        }
        jj_consume_token(99);
                e = new XMLLabelElement(parent, parent.getEndOffset(), ")");
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ExternalID(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYSTEM:
      t = jj_consume_token(SYSTEM);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      S(xmlNode, parent);
         switchTo(SysLiteral);
      t = jj_consume_token(SystemLiteral);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    case PUBLIC:
      t = jj_consume_token(PUBLIC);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      S(xmlNode, parent);
         switchTo(Publicid);
      t = jj_consume_token(PubidLiteral);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      S(xmlNode, parent);
         switchTo(SysLiteral);
      t = jj_consume_token(SystemLiteral);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PublicID(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    t = jj_consume_token(PUBLIC);
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
    S(xmlNode, parent);
         switchTo(Publicid);
    t = jj_consume_token(PubidLiteral);
                e = new XMLLabelElement(parent, parent.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void Element(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
XMLElement ee = null;
XMLStartTagElement ste = null;
XMLAbstractElement[] elems = null;
           xmlNode = getNextXMLNode(xmlNode);
           sindex.push(new Integer(0));

                ee = new XMLElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                elems = new XMLAbstractElement[]{ee};
                parent.replace(parent.getElementCount(), 0, elems);
    jj_consume_token(STAGSTART);
                ste = new XMLStartTagElement(xmlNode, doc, ee, ee.getEndOffset(), 0);
                elems = new XMLAbstractElement[]{ste};
                ee.replace(ee.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                XMLAbstractElement e = new XMLLabelElement(ste, ste.getEndOffset(), "<"+t.image);
                elems = new XMLAbstractElement[]{e};
                ste.replace(ste.getElementCount(), 0, elems);
    label_10:
    while (true) {
      if (jj_2_15(2)) {
        ;
      } else {
        break label_10;
      }
      S(xmlNode, ste);
      Attribute(xmlNode, ste);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, ste);
      break;
    default:
      jj_la1[76] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EMPTYTAGEND:
      t = jj_consume_token(EMPTYTAGEND);
                e = new XMLLabelElement(ste, ste.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ste.replace(ste.getElementCount(), 0, elems);
      break;
    case TAGEND:
      t = jj_consume_token(TAGEND);
                e = new XMLLabelElement(ste, ste.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ste.replace(ste.getElementCount(), 0, elems);
      Content(xmlNode, ee);
      ETag(xmlNode, ee);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         sindex.pop();
  }

  final public void ETag(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
                XMLEndTagElement ete = new XMLEndTagElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ete};
                parent.replace(parent.getElementCount(), 0, elems);
    jj_consume_token(ETAGSTART);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                XMLAbstractElement e = new XMLLabelElement(ete, ete.getEndOffset(), "</"+t.image);
                elems = new XMLAbstractElement[]{e};
                ete.replace(ete.getElementCount(), 0, elems);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, ete);
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    t = jj_consume_token(TAGEND);
                e = new XMLLabelElement(ete, ete.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ete.replace(ete.getElementCount(), 0, elems);
  }

  final public void CharContent(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
                xmlNode = getNextXMLNode(xmlNode);

                XMLContentElement ce = new XMLContentElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ce};
                parent.replace(parent.getElementCount(), 0, elems);
    t = jj_consume_token(CharData);
                XMLTextElement te = new XMLTextElement(ce, ce.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{te};
                ce.replace(ce.getElementCount(), 0, elems);
  }

  final public void Content(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
      switchTo(PCDataSect);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CharData:
      CharContent(xmlNode, parent);
      break;
    default:
      jj_la1[80] = jj_gen;
      ;
    }
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PISTART:
      case Amp:
      case ChRefHex:
      case ChRefDec:
      case STAGSTART:
      case Comment:
      case CDStart:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAGSTART:
        Element(xmlNode, parent);
        break;
      case Amp:
      case ChRefHex:
      case ChRefDec:
        Reference(xmlNode, parent);
        break;
      case CDStart:
        CDSect(xmlNode, parent);
        break;
      case PISTART:
        PI(xmlNode, parent);
        break;
      case Comment:
        Comment(xmlNode, parent);
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                switchTo(PCDataSect);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CharData:
        CharContent(xmlNode, parent);
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
    }
      switchTo(DEFAULT);
  }

  final public void CDSect(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
                XMLCDATAElement ce = new XMLCDATAElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ce};
                parent.replace(parent.getElementCount(), 0, elems);
    t = jj_consume_token(CDStart);
                XMLAbstractElement e = new XMLLabelElement(ce, ce.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);
    t = jj_consume_token(CDataContent);
                e = new XMLTextElement(ce, ce.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);
    t = jj_consume_token(CDEnd);
                e = new XMLLabelElement(ce, ce.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);
  }

  final public void Reference(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
String ref;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Amp:
      ref = EntityRef();
      break;
    case ChRefHex:
    case ChRefDec:
      ref = CharRef();
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                XMLContentElement ce = new XMLContentElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ce};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLTextElement te = new XMLTextElement(ce, ce.getEndOffset(),ref);
                elems = new XMLAbstractElement[]{te};
                ce.replace(ce.getElementCount(), 0, elems);
  }

  final public void Attribute(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
StringBuffer sb = new StringBuffer();
String value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                  sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
                   sb.append(t.image);
      break;
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    t = jj_consume_token(Eq);
               sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
                   sb.append(t.image);
      break;
    default:
      jj_la1[87] = jj_gen;
      ;
    }
    value = AttrValue();
            xmlNode = getNextXMLNode(xmlNode);

                int vlen = value.length();

                XMLAttributeElement ae = new XMLAttributeElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ae};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLAbstractElement e = new XMLLabelElement(ae, ae.getEndOffset(), sb.toString()+value.substring(0,1));
                elems = new XMLAbstractElement[]{e};
                ae.replace(ae.getElementCount(), 0, elems);

                if(vlen > 2) {
                        e = new XMLValueElement(ae, ae.getEndOffset(), value.substring(1,vlen -1));
                        elems = new XMLAbstractElement[]{e};
                        ae.replace(ae.getElementCount(), 0, elems);
                }

                e = new XMLLabelElement(ae, ae.getEndOffset(), value.substring(vlen-1));
                elems = new XMLAbstractElement[]{e};
                ae.replace(ae.getElementCount(), 0, elems);
  }

  final public String AttrValue() throws ParseException {
  StringBuffer lit =new StringBuffer();
  Token tok;
  String ref;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DQuotedDO:
      tok = jj_consume_token(DQuotedDO);
        lit.append(tok.image);
        switchTo(AttValueSectD);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Perc:
        case SemiColon:
        case Amp:
        case ChRefHex:
        case ChRefDec:
        case DQuotedRestAttValueD:
          ;
          break;
        default:
          jj_la1[88] = jj_gen;
          break label_12;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Amp:
          ref = EntityRef();
         lit.append(ref);
         switchTo(AttValueSectD);
          break;
        case ChRefHex:
        case ChRefDec:
          ref = CharRef();
        lit.append(ref);
        switchTo(AttValueSectD);
          break;
        case DQuotedRestAttValueD:
          tok = jj_consume_token(DQuotedRestAttValueD);
        lit.append(tok.image);
        switchTo(AttValueSectD);
          break;
        case SemiColon:
          tok = jj_consume_token(SemiColon);
        lit.append(tok.image);
        switchTo(AttValueSectD);
          break;
        case Perc:
          tok = jj_consume_token(Perc);
        lit.append(tok.image);
        switchTo(AttValueSectD);
          break;
        default:
          jj_la1[89] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      tok = jj_consume_token(DQuotedDC);
      lit.append(tok.image);
      {if (true) return lit.toString();}
      break;
    case DQuotedSO:
      tok = jj_consume_token(DQuotedSO);
        lit.append(tok.image);
        switchTo(AttValueSectS);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Perc:
        case SemiColon:
        case Amp:
        case ChRefHex:
        case ChRefDec:
        case DQuotedRestAttValueS:
          ;
          break;
        default:
          jj_la1[90] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Amp:
          ref = EntityRef();
         lit.append(ref);
         switchTo(AttValueSectS);
          break;
        case ChRefHex:
        case ChRefDec:
          ref = CharRef();
        lit.append(ref);
        switchTo(AttValueSectS);
          break;
        case DQuotedRestAttValueS:
          tok = jj_consume_token(DQuotedRestAttValueS);
        lit.append(tok.image);
        switchTo(AttValueSectS);
          break;
        case SemiColon:
          tok = jj_consume_token(SemiColon);
        lit.append(tok.image);
        switchTo(AttValueSectS);
          break;
        case Perc:
          tok = jj_consume_token(Perc);
        lit.append(tok.image);
        switchTo(AttValueSectS);
          break;
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      tok = jj_consume_token(DQuotedSC);
      lit.append(tok.image);
      {if (true) return lit.toString();}
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String EntityRef() throws ParseException {
StringBuffer sb = new StringBuffer();
Token t;
    t = jj_consume_token(Amp);
                sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Name:
      t = jj_consume_token(Name);
      break;
    case VERSION:
    case ANY:
    case RMD:
    case RMD_NONE:
    case RMD_ALL:
    case RMD_INTERNAL:
    case EMPTY:
    case ID:
    case IDREF:
    case IDREFS:
    case ENTITY:
    case ENTITIES:
    case NMTOKEN:
    case NMTOKENS:
    case NOTATION:
    case CDATA:
    case NDATA:
    case IGNORE:
    case INCLUDE:
    case PUBLIC:
    case SYSTEM:
      t = KeyWords();
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                  sb.append(t.image);
    jj_consume_token(SemiColon);
                    sb.append(";");
         {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String CharRef() throws ParseException {
  Token t;
  StringBuffer sb = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ChRefHex:
      t = jj_consume_token(ChRefHex);
                 sb.append(t.image);
      t = jj_consume_token(Hex4);
             sb.append(t.image);
      jj_consume_token(SemiColon);
                sb.append(";");
      {if (true) return sb.toString();}
      break;
    case ChRefDec:
      t = jj_consume_token(ChRefDec);
                 sb.append(t.image);
      t = jj_consume_token(Dec);
            sb.append(t.image);
      jj_consume_token(SemiColon);
                sb.append(";");
      {if (true) return sb.toString();}
      break;
    default:
      jj_la1[94] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void PI(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    jj_consume_token(PISTART);
    t = jj_consume_token(PI);
                xmlNode = getNextXMLNode(xmlNode);

                XMLProcInstrElement pie = new XMLProcInstrElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{pie};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLAbstractElement e = new XMLLabelElement(pie, pie.getEndOffset(), "<?");
                elems = new XMLAbstractElement[]{e};
                pie.replace(pie.getElementCount(), 0, elems);

                String pi = t.image.substring(0, t.image.length()-2);
                e = new XMLProcInstrDataElement(pie, pie.getEndOffset(), pi);
                elems = new XMLAbstractElement[]{e};
                pie.replace(pie.getElementCount(), 0, elems);

                e = new XMLLabelElement(pie, pie.getEndOffset(), "?>");
                elems = new XMLAbstractElement[]{e};
                pie.replace(pie.getElementCount(), 0, elems);
  }

  final public void Comment(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    t = jj_consume_token(Comment);
                xmlNode = getNextXMLNode(xmlNode);

                XMLCommentElement ce = new XMLCommentElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{ce};
                parent.replace(parent.getElementCount(), 0, elems);

                XMLAbstractElement e = new XMLLabelElement(ce, ce.getEndOffset(), "<!--");
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);

                String comment = t.image.substring(4, t.image.length()-3);
                e = new XMLCommentDataElement(ce, ce.getEndOffset(), comment);
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);

                e = new XMLLabelElement(ce, ce.getEndOffset(), "-->");
                elems = new XMLAbstractElement[]{e};
                ce.replace(ce.getElementCount(), 0, elems);
  }

  final public void Misc(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PISTART:
      PI(xmlNode, parent);
      break;
    case Comment:
      Comment(xmlNode, parent);
      break;
    case Space:
      S(xmlNode, parent);
      break;
    default:
      jj_la1[95] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void S(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
    t = jj_consume_token(Space);
                XMLAbstractElement e = new XMLWhiteSpaceElement(parent, parent.getEndOffset(), t.image);
                XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
  }

  final public void XMLDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
XMLDeclElement xde = new XMLDeclElement(xmlNode, doc, parent, parent.getEndOffset(), 0);
Token t;
                XMLAbstractElement[] elems = new XMLAbstractElement[]{xde};
                parent.replace(parent.getElementCount(), 0, elems);
    t = jj_consume_token(XMLDeclStart);
                XMLAbstractElement e = new XMLLabelElement(xde, xde.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                xde.replace(xde.getElementCount(), 0, elems);
    VersionInfo(xmlNode, xde);
    if (jj_2_16(2)) {
      EncodingDecl(xmlNode, xde);
    } else {
      ;
    }
    if (jj_2_17(2)) {
      SDDecl(xmlNode, xde);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      S(xmlNode, xde);
      break;
    default:
      jj_la1[96] = jj_gen;
      ;
    }
    t = jj_consume_token(XMLDeclEnd);
                e = new XMLLabelElement(xde, xde.getEndOffset(), t.image);
                elems = new XMLAbstractElement[]{e};
                xde.replace(xde.getElementCount(), 0, elems);
  }

  final public void VersionInfo(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
StringBuffer sb = new StringBuffer();
    S(xmlNode, parent);
    t = jj_consume_token(VERSION);
               sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
             sb.append(t.image);
      break;
    default:
      jj_la1[97] = jj_gen;
      ;
    }
    t = jj_consume_token(Eq);
          sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
              sb.append(t.image);
      break;
    default:
      jj_la1[98] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ONEZED:
      t = jj_consume_token(ONEZED);
               sb.append(t.image);
      break;
    case ONEZES:
      t = jj_consume_token(ONEZES);
                                                  sb.append(t.image);
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), sb.toString());
        XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
        parent.replace(parent.getElementCount(), 0, elems);
        sb.setLength(0);
  }

  final public void EncodingDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
StringBuffer sb = new StringBuffer();
    S(xmlNode, parent);
    t = jj_consume_token(Encod);
             sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
               sb.append(t.image);
      break;
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    t = jj_consume_token(Eq);
            sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
               sb.append(t.image);
      break;
    default:
      jj_la1[101] = jj_gen;
      ;
    }
    t = jj_consume_token(QEncoding);
                 sb.append(t.image);
        XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), sb.toString());
        XMLAbstractElement[] elems = new XMLAbstractElement[]{e};
        parent.replace(parent.getElementCount(), 0, elems);
        sb.setLength(0);
  }

  final public void SDDecl(XMLNode xmlNode, XMLBranchElement parent) throws ParseException {
Token t;
StringBuffer sb = new StringBuffer();
    S(xmlNode, parent);
    t = jj_consume_token(STANDALONE);
                        sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
                     sb.append(t.image);
      break;
    default:
      jj_la1[102] = jj_gen;
      ;
    }
    t = jj_consume_token(Eq);
                  sb.append(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Space:
      t = jj_consume_token(Space);
                     sb.append(t.image);
      break;
    default:
      jj_la1[103] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case YESZES:
      t = jj_consume_token(YESZES);
                    sb.append(t.image);
      break;
    case NOZES:
      t = jj_consume_token(NOZES);
                                                      sb.append(t.image);
      break;
    case YESZED:
      t = jj_consume_token(YESZED);
                                                                                         sb.append(t.image);
      break;
    case NOZED:
      t = jj_consume_token(NOZED);
                                                                                                                          sb.append(t.image);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                XMLAbstractElement e = new XMLLabelElement(parent, parent.getEndOffset(), sb.toString());
                XMLAbstractElement[]elems = new XMLAbstractElement[]{e};
                parent.replace(parent.getElementCount(), 0, elems);
                sb.setLength(0);
  }

  final public XMLDocumentElement Document(XMLDocument doc, XMLNode root) throws ParseException {
this.doc = doc;
XMLDocumentElement de = new XMLDocumentElement(root, doc);
    try {
                 sindex.push(new Integer(0));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XMLDeclStart:
        XMLDecl(root, de);
        break;
      default:
        jj_la1[105] = jj_gen;
        ;
      }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PISTART:
        case Space:
        case Comment:
          ;
          break;
        default:
          jj_la1[106] = jj_gen;
          break label_14;
        }
        Misc(root, de);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 96:
        doctypedecl(root, de);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PISTART:
          case Space:
          case Comment:
            ;
            break;
          default:
            jj_la1[107] = jj_gen;
            break label_15;
          }
          Misc(root, de);
        }
        break;
      default:
        jj_la1[108] = jj_gen;
        ;
      }
      Element(root, de);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PISTART:
        case Space:
        case Comment:
          ;
          break;
        default:
          jj_la1[109] = jj_gen;
          break label_16;
        }
        Misc(root, de);
      }
                 sindex.pop();
    } catch (TokenMgrError e) {
                recoverFromError(e);
    } catch (ParseException e) {
                recoverFromError(e);
    }
         {if (true) return de;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_3R_36() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_14() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_13()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_38()) jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    if (jj_scan_token(106)) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(NDATA)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_5() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    }
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(97)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) jj_scanpos = xsp;
    if (jj_scan_token(PC)) return true;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(Space)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(107)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(106)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_17()) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(105)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    return false;
  }

  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    }
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(97)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_62()) jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(STANDALONE)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(97)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    if (jj_3_9()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_52()) jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(103)) return true;
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(PUBLIC)) return true;
    if (jj_3R_17()) return true;
    if (jj_scan_token(PubidLiteral)) return true;
    if (jj_3R_17()) return true;
    if (jj_scan_token(SystemLiteral)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_17()) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(SYSTEM)) return true;
    if (jj_3R_17()) return true;
    if (jj_scan_token(SystemLiteral)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(Encod)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) jj_scanpos = xsp;
    if (jj_scan_token(99)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    xsp = jj_scanpos;
    if (jj_3R_36()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_44()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public XML10ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[110];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xf1f80010,0xf1f80010,0x0,0x0,0x2000,0x0,0xf1f80010,0x0,0x0,0xf1f80010,0x0,0xf1f80010,0x0,0xf1f80010,0x0,0xf1f80010,0x0,0x0,0xf1f80010,0x8000000,0xe000000,0xf0000000,0x0,0x0,0xf1f80010,0x0,0x0,0xf1f80010,0x0,0x4,0x4,0x0,0x4,0x0,0xf1f80010,0x0,0xf1f80010,0x0,0x0,0xf1f80010,0xf1f80010,0xf1f80010,0xf1f80010,0xf1f80010,0xf1f80010,0x0,0x0,0xf1f80010,0xf1f80010,0x1080000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf1f80010,0xf1f80010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf1f80010,0x0,0x0,0x0,0x0,0xf1f80010,0x0,0x18000,0xf1f80010,0x0,0x0,0x4,0x4,0x0,0x0,0xf1f80010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf1f80010,0x0,0x4,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x780,0x2,0x4,0x4,0x0,0x4,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x3ff,0x7ff,0x80000,0x80000,0x0,0x80000,0x7ff,0x80000,0x80000,0x7ff,0x80000,0x7ff,0x80000,0x7ff,0x80000,0x7ff,0x100,0x80000,0x7ff,0x0,0x0,0x1f,0x8,0x80000,0x7ff,0x80000,0x80000,0x7ff,0x80000,0x80000,0x80000,0x80000,0x0,0x0,0x7ff,0x80000,0x7ff,0x80000,0x300,0x7ff,0x7ff,0x7ff,0x7ff,0x7ff,0x7ff,0x0,0x300,0x7ff,0x7ff,0x0,0x0,0x80000,0x80000,0x80000,0x80000,0x80000,0x80000,0x80000,0x80000,0x7ff,0x7ff,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x80000,0x7ff,0x80000,0x80000,0x80000,0x300,0x7ff,0x80000,0x0,0x7ff,0x80000,0x0,0x0,0x0,0x0,0x0,0x7ff,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x7ff,0x0,0x80000,0x80000,0x80000,0x80000,0x0,0x80000,0x80000,0x80000,0x80000,0x0,0x0,0x80000,0x80000,0x0,0x80000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x900,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40004,0x40004,0x4,0x40000,0x0,0x0,0x0,0x0,0x0,0x900,0x74,0x0,0x74,0x74,0x0,0x74,0x900,0x900,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x250070,0x250070,0x100000,0x70,0x0,0x0,0x0,0x47c,0x47c,0x207c,0x207c,0x900,0x0,0x60,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0x40000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0xf0,0x0,0xf0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0xe00,0xe00,0x2,0xe00,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[17];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public XML10Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XML10Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XML10ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public XML10Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XML10ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public XML10Parser(XML10ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(XML10ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 110; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[108];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 110; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 108; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 17; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
