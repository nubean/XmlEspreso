/* Generated By:JJTree&JavaCC: Do not edit this line. CSSParser.java */
/*
The MIT License (MIT)

Copyright (c) 2015 NuBean LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

package com.nubean.css.parser;

import javax.swing.text.Document;
import org.xml.sax.SAXParseException;

import com.nubean.michbase.DefaultErrorHandler;

public class CSSParser/*@bgen(jjtree)*/implements CSSParserTreeConstants, CSSParserConstants {/*@bgen(jjtree)*/
  protected JJTCSSParserState jjtree = new JJTCSSParserState();private Document document;
        private DefaultErrorHandler errorHandler;
        private ParseException lastException;
        private TokenMgrError tokenError;

        public void setErrorHandler(DefaultErrorHandler errorHandler) {
                this.errorHandler = errorHandler;
        }

        private void recoverFromError(ParseException e) {
         lastException = e;
         try {
                if(errorHandler != null) {

                        SAXParseException spe = null;
                                if(e.currentToken.next != null) {
                                        spe = new SAXParseException(e.getMessage(), null, null,
                                                e.currentToken.next.beginLine, e.currentToken.next.beginColumn);
                                } else {
                                        spe = new SAXParseException(e.getMessage(), null, null,
                                                e.currentToken.beginLine, e.currentToken.beginColumn);
                                }
                        errorHandler.error(spe);

        }

          } catch(Exception sae) {

      }

     }

     private void recoverFromError(TokenMgrError e) {
      tokenError = e;
          try {
                if(errorHandler != null) {
                        SAXParseException spe =
                         new SAXParseException(e.getMessage(), null, null,0,0);
                errorHandler.error(spe);
        }
          } catch(Exception sae) {

      }
     }

        private void jjtreeOpenNodeScope(SimpleNode sn) {
      sn.setFirstToken(getToken(1));
    }

    private  void jjtreeCloseNodeScope(SimpleNode sn){
      sn.setLastToken(getToken(0));
    }

    public Document getDocument() {
        return  document;
    }

    public void setDocument(Document document) {
        this.document = document;
    }

    public ParseException getParseException() {
        return lastException;
    }

    public TokenMgrError getTokenMgrError() {
        return tokenError;
    }

     private void switchTo(int state) {
        token_source.SwitchTo(state);
        if(token.next != null) {
                if(token.next.image != null)
                        jj_input_stream.backup(token.next.image.length());
                token.next = null;
        }
    }

    public void setTabSize(int size) {
     jj_input_stream.setTabSize(size);
    }

  final public ASTcss stylesheet() throws ParseException {
 /*@bgen(jjtree) css */
  ASTcss jjtn000 = new ASTcss(this, JJTCSS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
                lastException = null;
                tokenError = null;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARSET_SYM:
          jj_consume_token(CHARSET_SYM);
          jj_consume_token(STRING);
          jj_consume_token(SEMI_COLON);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
          case CDO:
          case CDC:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_1;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            jj_consume_token(SPACE);
            break;
          case CDO:
            jj_consume_token(CDO);
            break;
          case CDC:
            jj_consume_token(CDC);
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IMPORT_SYM:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_2;
          }
          imports();
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SPACE:
            case CDO:
            case CDC:
              ;
              break;
            default:
              jj_la1[4] = jj_gen;
              break label_3;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SPACE:
              jj_consume_token(SPACE);
              break;
            case CDO:
              jj_consume_token(CDO);
              break;
            case CDC:
              jj_consume_token(CDC);
              break;
            default:
              jj_la1[5] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENT:
          case HASH:
          case COLON:
          case PERIOD:
          case ASTERISK:
          case LSQBRKT:
          case PAGE_SYM:
          case MEDIA_SYM:
            ;
            break;
          default:
            jj_la1[6] = jj_gen;
            break label_4;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENT:
          case HASH:
          case COLON:
          case PERIOD:
          case ASTERISK:
          case LSQBRKT:
            ruleset();
            break;
          case MEDIA_SYM:
            media();
            break;
          case PAGE_SYM:
            page();
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SPACE:
            case CDO:
            case CDC:
              ;
              break;
            default:
              jj_la1[8] = jj_gen;
              break label_5;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SPACE:
              jj_consume_token(SPACE);
              break;
            case CDO:
              jj_consume_token(CDO);
              break;
            case CDC:
              jj_consume_token(CDC);
              break;
            default:
              jj_la1[9] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(0);
      } catch (ParseException e) {
                recoverFromError(e);
      } catch (TokenMgrError te) {
                recoverFromError(te);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
         {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void imports() throws ParseException {
 /*@bgen(jjtree) imports */
  ASTimports jjtn000 = new ASTimports(this, JJTIMPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IMPORT_SYM);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_6;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        jj_consume_token(STRING);
        break;
      case URI:
        jj_consume_token(URI);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_7;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        medium();
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMA:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMA);
          label_9:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SPACE:
              ;
              break;
            default:
              jj_la1[14] = jj_gen;
              break label_9;
            }
            jj_consume_token(SPACE);
          }
          medium();
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(SEMI_COLON);
      label_10:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_10;
        }
        jj_consume_token(SPACE);
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void media() throws ParseException {
 /*@bgen(jjtree) media */
  ASTmedia jjtn000 = new ASTmedia(this, JJTMEDIA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(MEDIA_SYM);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_11;
        }
        jj_consume_token(SPACE);
      }
      medium();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMA:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMA);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_13;
          }
          jj_consume_token(SPACE);
        }
        medium();
      }
      jj_consume_token(LBRACE);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_14;
        }
        jj_consume_token(SPACE);
      }
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
        case HASH:
        case COLON:
        case PERIOD:
        case ASTERISK:
        case LSQBRKT:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_15;
        }
        ruleset();
      }
      jj_consume_token(RBRACE);
      label_16:
      while (true) {
        if (jj_2_2(2)) {
          ;
        } else {
          break label_16;
        }
        jj_consume_token(SPACE);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void medium() throws ParseException {
    jj_consume_token(IDENT);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_17;
      }
      jj_consume_token(SPACE);
    }
  }

  final public void page() throws ParseException {
 /*@bgen(jjtree) page */
  ASTpage jjtn000 = new ASTpage(this, JJTPAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PAGE_SYM);
      label_18:
      while (true) {
        if (jj_2_3(2)) {
          ;
        } else {
          break label_18;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        pseudo_page();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_19;
        }
        jj_consume_token(SPACE);
      }
      jj_consume_token(LBRACE);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_20;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMI_COLON:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_21;
        }
        jj_consume_token(SEMI_COLON);
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_22;
          }
          jj_consume_token(SPACE);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          declaration();
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
      }
      jj_consume_token(RBRACE);
      label_23:
      while (true) {
        if (jj_2_4(2)) {
          ;
        } else {
          break label_23;
        }
        jj_consume_token(SPACE);
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  final public void pseudo_page() throws ParseException {
    jj_consume_token(COLON);
    jj_consume_token(IDENT);
  }

  final public void operator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 75:
      jj_consume_token(75);
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_24;
        }
        jj_consume_token(SPACE);
      }
      break;
    case COMA:
      jj_consume_token(COMA);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_25;
        }
        jj_consume_token(SPACE);
      }
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void combinator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_26;
        }
        jj_consume_token(SPACE);
      }
      break;
    case GREATER:
      jj_consume_token(GREATER);
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_27;
        }
        jj_consume_token(SPACE);
      }
      break;
    case SPACE:
      jj_consume_token(SPACE);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void unary_operator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void property() throws ParseException {
    jj_consume_token(IDENT);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_28;
      }
      jj_consume_token(SPACE);
    }
  }

  final public void ruleset() throws ParseException {
 /*@bgen(jjtree) ruleset */
  ASTruleset jjtn000 = new ASTruleset(this, JJTRULESET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      selector();
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMA:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_29;
        }
        jj_consume_token(COMA);
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[38] = jj_gen;
            break label_30;
          }
          jj_consume_token(SPACE);
        }
        selector();
      }
      jj_consume_token(LBRACE);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_31;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMI_COLON:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_32;
        }
        jj_consume_token(SEMI_COLON);
        label_33:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[42] = jj_gen;
            break label_33;
          }
          jj_consume_token(SPACE);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          declaration();
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
      }
      jj_consume_token(RBRACE);
      label_34:
      while (true) {
        if (jj_2_5(2)) {
          ;
        } else {
          break label_34;
        }
        jj_consume_token(SPACE);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void selector() throws ParseException {
 /*@bgen(jjtree) selector */
  ASTselector jjtn000 = new ASTselector(this, JJTSELECTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      simple_selector();
      label_35:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
        case PLUS:
        case GREATER:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_35;
        }
        combinator();
        simple_selector();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void simple_selector() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
    case ASTERISK:
      element_name();
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
        case COLON:
        case PERIOD:
        case LSQBRKT:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_36;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          jj_consume_token(HASH);
          break;
        case PERIOD:
          class_name();
          break;
        case LSQBRKT:
          attrib();
          break;
        case COLON:
          pseudo();
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case HASH:
    case COLON:
    case PERIOD:
    case LSQBRKT:
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          jj_consume_token(HASH);
          break;
        case PERIOD:
          class_name();
          break;
        case LSQBRKT:
          attrib();
          break;
        case COLON:
          pseudo();
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
        case COLON:
        case PERIOD:
        case LSQBRKT:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_37;
        }
      }
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void class_name() throws ParseException {
    jj_consume_token(PERIOD);
    jj_consume_token(IDENT);
  }

  final public void element_name() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      jj_consume_token(IDENT);
      break;
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void attrib() throws ParseException {
    jj_consume_token(LSQBRKT);
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_38;
      }
      jj_consume_token(SPACE);
    }
    jj_consume_token(IDENT);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_39;
      }
      jj_consume_token(SPACE);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case INCLUDES:
    case DASHMATCH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
        break;
      case INCLUDES:
        jj_consume_token(INCLUDES);
        break;
      case DASHMATCH:
        jj_consume_token(DASHMATCH);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_40;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        jj_consume_token(IDENT);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_41;
        }
        jj_consume_token(SPACE);
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    jj_consume_token(RSQBRKT);
  }

  final public void pseudo() throws ParseException {
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      jj_consume_token(IDENT);
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      label_42:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_42;
        }
        jj_consume_token(SPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        jj_consume_token(IDENT);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_43;
        }
        jj_consume_token(SPACE);
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void declaration() throws ParseException {
 /*@bgen(jjtree) declaration */
  ASTdeclaration jjtn000 = new ASTdeclaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      property();
      jj_consume_token(COLON);
      label_44:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_44;
        }
        jj_consume_token(SPACE);
      }
      expr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORTANT_SYM:
        prio();
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void prio() throws ParseException {
    jj_consume_token(IMPORTANT_SYM);
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_45;
      }
      jj_consume_token(SPACE);
    }
  }

  final public void expr() throws ParseException {
    term();
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case IDENT:
      case HASH:
      case NUMBER:
      case URI:
      case FUNCTION:
      case COMA:
      case PLUS:
      case EMS:
      case EXS:
      case LENGTH:
      case ANGLE:
      case TIME:
      case FREQ:
      case PERCENTAGE:
      case 75:
      case 76:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_46;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMA:
      case 75:
        operator();
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      term();
    }
  }

  final public void term() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case PLUS:
    case EMS:
    case EXS:
    case LENGTH:
    case ANGLE:
    case TIME:
    case FREQ:
    case PERCENTAGE:
    case 76:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case 76:
        unary_operator();
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        jj_consume_token(NUMBER);
        label_47:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[67] = jj_gen;
            break label_47;
          }
          jj_consume_token(SPACE);
        }
        break;
      case PERCENTAGE:
        jj_consume_token(PERCENTAGE);
        label_48:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[68] = jj_gen;
            break label_48;
          }
          jj_consume_token(SPACE);
        }
        break;
      case LENGTH:
        jj_consume_token(LENGTH);
        label_49:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[69] = jj_gen;
            break label_49;
          }
          jj_consume_token(SPACE);
        }
        break;
      case EMS:
        jj_consume_token(EMS);
        label_50:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[70] = jj_gen;
            break label_50;
          }
          jj_consume_token(SPACE);
        }
        break;
      case EXS:
        jj_consume_token(EXS);
        label_51:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[71] = jj_gen;
            break label_51;
          }
          jj_consume_token(SPACE);
        }
        break;
      case ANGLE:
        jj_consume_token(ANGLE);
        label_52:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[72] = jj_gen;
            break label_52;
          }
          jj_consume_token(SPACE);
        }
        break;
      case TIME:
        jj_consume_token(TIME);
        label_53:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[73] = jj_gen;
            break label_53;
          }
          jj_consume_token(SPACE);
        }
        break;
      case FREQ:
        jj_consume_token(FREQ);
        label_54:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[74] = jj_gen;
            break label_54;
          }
          jj_consume_token(SPACE);
        }
        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case STRING:
      jj_consume_token(STRING);
      label_55:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[76] = jj_gen;
          break label_55;
        }
        jj_consume_token(SPACE);
      }
      break;
    case IDENT:
      jj_consume_token(IDENT);
      label_56:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_56;
        }
        jj_consume_token(SPACE);
      }
      break;
    case URI:
      jj_consume_token(URI);
      label_57:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_57;
        }
        jj_consume_token(SPACE);
      }
      break;
    case HASH:
      hexcolor();
      break;
    case FUNCTION:
      function();
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void function() throws ParseException {
    jj_consume_token(FUNCTION);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_58;
      }
      jj_consume_token(SPACE);
    }
    expr();
    jj_consume_token(RPAREN);
    label_59:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_59;
      }
      jj_consume_token(SPACE);
    }
  }

/*
 * There is a constraint on the color that it must
 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
 */
  final public void hexcolor() throws ParseException {
    jj_consume_token(HASH);
    label_60:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_60;
      }
      jj_consume_token(SPACE);
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_3_4() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public CSSParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[83];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x2,0x2,0x0,0x2,0x2,0x30,0x30,0x2,0x2,0x2,0x4,0x2,0x0,0x2,0x10,0x2,0x0,0x2,0x2,0x30,0x2,0x0,0x2,0x2,0x10,0x0,0x2,0x10,0x2,0x2,0x0,0x2,0x2,0x2,0x0,0x2,0x0,0x2,0x2,0x10,0x0,0x2,0x10,0x2,0x20,0x20,0x20,0x20,0x30,0x10,0x2,0x2,0x0,0x2,0x14,0x2,0x0,0x10,0x2,0x10,0x2,0x80,0x2,0x74,0x0,0x0,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x40,0x2,0x2,0x2,0x74,0x2,0x2,0x2,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1000000,0x6000000,0x6000000,0x400000,0x6000000,0x6000000,0xa1e000,0xa1e000,0x6000000,0x6000000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e000,0x0,0x2000,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x16000,0x16000,0x16000,0x16000,0x1e000,0x8000,0x0,0x0,0x18040000,0x0,0x0,0x0,0x18040000,0x0,0x0,0x40000000,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x801,0x0,0x0,0x6,0x1002,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1dfb,0x801,0x1002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5f8,0x0,0x0,0x0,0x15fa,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CSSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CSSParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CSSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CSSParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CSSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CSSParser(CSSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CSSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 83; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[77];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 83; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 77; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
